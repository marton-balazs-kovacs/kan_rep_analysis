---
title: "Kan_Analysis"
author: "Marton Kovacs"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  word_document: default
  html_document: default
---

# Load packages

```{r, message = FALSE, warning = FALSE}
library(tidyverse)
library(osfr)
library(readxl)
library(readbulk)
library(ez)
library(psych)
```

# Load custom functions

```{r}
source("R/utils.R")
source("R/arcsine_transformation.R")
```

# Exp1
## Outcome neutral test
### Test sentence reading time
#### Import data

```{r}
outcome_neutral_sentence_data <- read_tsv("Data/Processed/Exp1/Kan_Processed_Exp1_OutcomeNeutral_Sentence_data.tsv")
```

#### Nest the data

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  nest(data = c(participant_id, Congruent, Incongruent))
```

#### Performing the t-tests

We calculate the t test for each sentence region separately.

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  mutate(t_value = map_dbl(data,
                       ~ t.test(.$Incongruent, .$Congruent, paired = TRUE, alternative = "greater") %>% 
                         broom::tidy() %>% 
                         pull(statistic)),
         df = map_dbl(data,
                       ~ t.test(.$Incongruent, .$Congruent, paired = TRUE, alternative = "greater") %>% 
                         broom::tidy() %>% 
                         pull(parameter)),
         p_value = map_dbl(data,
                       ~ t.test(.$Incongruent, .$Congruent, paired = TRUE, alternative = "greater") %>% 
                         broom::tidy() %>% 
                         pull(p.value)),
         raw_effect = map_dbl(data,
                       ~ t.test(.$Incongruent, .$Congruent, paired = TRUE, alternative = "greater") %>% 
                         broom::tidy() %>% 
                         pull(estimate)))
```

#### Calculating the SE

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  mutate(se = map2_dbl(raw_effect, t_value,
                       ~ abs(.x / .y)))
```

#### Calculating the Bayes factor

We are calculating the Bf for all the regions, but our main interest is the the temporarily ambiguous and disambiguating region.

Checking the number of observations for each sentence region.

```{r}
map(outcome_neutral_sentence_data$data, nrow)
```

Creating a plots to visualize the difference.

We are creating a plot function for visualization.

```{r}
sentence_region_plot <- function(df, name) {
  df %>%
  select(Congruent, Incongruent) %>% 
  gather(key = "congruency", value = "resid_mean_reading_time") %>%  
  group_by(congruency) %>% 
  summarise(n = n(),
            mean = mean(resid_mean_reading_time),
            sd = sd(resid_mean_reading_time, na.rm = T),
            se = sd / sqrt(n)) %>% 
  ggplot() +
  aes(x = congruency,
      y = mean) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = mean - (se * 1.96),
                    ymax = mean + (se  * 1.96)),
                width = .1) +
  labs(title = paste("Sentence region", name),
       x = "Congruency of the sentence region",
       y = "Mean residual reading time") +
  theme_minimal() +
  theme(
    title = element_text(size = 8),
    # axis.title = element_text(size = 5),
    axis.text.y = element_text(size = 5)
    # strip.text.x = element_text(size = 5)
    )
}

outcome_neutral_sentence_data <- 
  outcome_neutral_sentence_data %>% 
  mutate(sentence_plot = map2(data, as.character(sentence_region_no), 
                     ~ sentence_region_plot(.x, .y)))
```

Create one plot to show all of the sentence plots together.

```{r}
plot_1 <- outcome_neutral_sentence_data$sentence_plot[[1]] +
  theme(axis.title.x = element_blank())
plot_2 <- outcome_neutral_sentence_data$sentence_plot[[2]] +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank())
plot_3 <- outcome_neutral_sentence_data$sentence_plot[[3]] +
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank())
plot_4 <- outcome_neutral_sentence_data$sentence_plot[[4]] +
  theme(axis.title.x = element_blank())
plot_5 <- outcome_neutral_sentence_data$sentence_plot[[5]] +
  theme(axis.title.y = element_blank())
plot_6 <- outcome_neutral_sentence_data$sentence_plot[[6]] +
  theme(axis.title.y = element_blank())
plot_7 <- outcome_neutral_sentence_data$sentence_plot[[7]]

reading_time_plot <-
  cowplot::plot_grid(plot_1, plot_2, plot_3,
                     plot_4, plot_5, plot_6,
                     plot_7)

ggsave("Figures/Kan_Exp1_ReadingTime_Plot.png", device = "png", plot = reading_time_plot, dpi = 300, width = 208, height = 118, units = "mm")

reading_time_plot
```

Assigning SD theory for the Bayes factor analysis.

```{r}
outcome_neutral_sentence_data <- 
  outcome_neutral_sentence_data %>% 
  mutate(sd_theory = case_when(sentence_region_no == 3 ~ 40L,
                               sentence_region_no == 4 ~ 18L,
                               TRUE ~ 18L))
```

Running the Bf analysis for all sentence regions.

```{r}
outcome_neutral_sentence_data <- 
  outcome_neutral_sentence_data %>% 
  mutate(bf = pmap_dbl(list(se, raw_effect, df, sd_theory),
                       ~ Bf(sd = ..1,
                            obtained = ..2,
                            dfdata = ..3,
                            meanoftheory = 0,
                            sdtheory = ..4,
                            dftheory = 10^10,
                            tail = 1)))
```

Create table with results.

```{r}
outcome_neutral_sentence_table <-
  outcome_neutral_sentence_data %>% 
  mutate(raw_effect = round(raw_effect, 2),
         bf = round(bf, 2),
         t_value = round(t_value, 2),
         p_value = round(p_value, 2),
         se = round(se, 2)) %>% 
  rename(`Sentence region id` = sentence_region_no,
         `t value` = t_value,
         DF = df,
         `p value` = p_value,
         `Raw effect` = raw_effect,
         SE = se,
         B = bf) %>% 
  select(-sentence_region_type,
         -data,
         -sentence_plot,
         -sd_theory)

papaja::apa_table(
  outcome_neutral_sentence_table,
  caption = "Results of the Comparison of the Mean Residual Reading Times in Each Sentence Region",
  escape = TRUE
)
```

Calculating the robustness region for temporarily ambiguous region.

```{r}
temporarily_data <- 
  outcome_neutral_sentence_data %>% 
  filter(sentence_region_type == "temporarly ambiguous")

sd <- 
  temporarily_data %>% 
  pull(se)

obtained <- 
  temporarily_data %>% 
  pull(raw_effect)

df <- 
  temporarily_data %>% 
  pull(df)

# lower
Bf(sd = sd,
   obtained = obtained,
   dfdata = df,
   meanoftheory = 0,
   sdtheory = 0.6,
   dftheory = 10^10,
   tail = 1)

# upper
Bf(sd = sd,
   obtained = obtained,
   dfdata = df,
   meanoftheory = 0,
   sdtheory = 6125,
   dftheory = 10^10,
   tail = 1)
```

Calculating the robustness region for disambuguating region.

```{r}
disambiguating_data <- 
  outcome_neutral_sentence_data %>% 
  filter(sentence_region_type == "disambiguating ambiguous")

sd <- 
  disambiguating_data %>% 
  pull(se)

obtained <- 
  disambiguating_data %>% 
  pull(raw_effect)

df <- 
  disambiguating_data %>% 
  pull(df)

# lower
Bf(sd = sd,
   obtained = obtained,
   dfdata = df,
   meanoftheory = 0,
   sdtheory = 17.2,
   dftheory = 10^10,
   tail = 1)

# upper
Bf(sd = sd,
   obtained = obtained,
   dfdata = df,
   meanoftheory = 0,
   sdtheory = 173,
   dftheory = 10^10,
   tail = 1)
```

## Crucial tests
### Reaction time analysis
#### Import data

```{r}
main_analysis_rt_data <- vroom::vroom("Data/Processed/Exp1/Kan_Processed_Exp1_Main_Rt_data.tsv")
```

#### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  count(participant_id)
```

The number of participants.

```{r}
main_analysis_rt_data %>% 
  distinct(participant_id) %>% 
  count()
```

#### Figures

The congruency sequence effect for the reaction time responses.

```{r}
kan_exp1_rt_cse_plot <-
  main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(participant_mean_rt = mean(response_time, na.rm = T)) %>%
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(participant_mean_rt, na.rm = T),
            sd_rt = sd(participant_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>% 
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - (se_rt * 1.96),
                    ymax = mean_rt + (se_rt * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time (ms)") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = c(.85, .4))

kan_exp1_rt_cse_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp1_Rt_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp1_rt_cse_plot)
```

#### Data preprocessing

We are calculating the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup() %>% 
  mutate(is_congruent = as.factor(is_congruent),
         is_previous_congruent = as.factor(is_previous_congruent),
         participant_id = as.factor(participant_id))
```

The number of conditions per participant. Because we excluded the incorrect trials, it can happen that a participant does no have reaction time responses from all the 4 conditions.

```{r}
main_analysis_rt_aggregate %>% 
  count(participant_id) %>% 
  arrange(n)
```

Save the [participant_id] of those participants who do not have data from all the four conditions.

```{r}
missing_condition <-
  main_analysis_rt_aggregate %>% 
  count(participant_id) %>% 
  filter(n != 4) %>%
  select(participant_id)
```

The number of participants who has missing conditions.

```{r}
nrow(missing_condition)
```

Calculating the raw congruency, previous congruency and interaction effect for each participant.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (ci - cc) - (ii - ic))
```

Running the repeated measure ANOVA.

```{r}
anova_rt <-
  aov(rt_conditional_mean ~ is_congruent * is_previous_congruent + Error(participant_id / (is_congruent * is_previous_congruent)), data = main_analysis_rt_aggregate)
```

Saving the F value and Df for each effect of interest.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  broom::tidy() %>% 
  select(term, statistic) %>% 
  transmute(term = case_when(term == "is_congruent" ~ "main_effect_congruent",
                             term == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             term == "is_congruent:is_previous_congruent" ~ "interaction_effect",
                             term == "Residuals" ~ term),
            f_value = statistic) %>% 
  filter(!is.na(f_value))
```

Show the results of the ANOVA.

```{r}
anova_rt %>% 
  broom::tidy() %>% 
  rename(f_value = statistic,
         p_value = p.value) %>% 
  mutate(f_value = round(f_value, 2),
         p_value = round(p_value, 2)) %>% 
  filter(!is.na(f_value))
```

Calculating the raw effects summarized for every participant.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T),
            n_participant = n()) %>%
  gather(key = "term", value = "raw_effect", -n_participant)
```

Joining the calculated F values and Dfs with the raw effects.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

Calculating the SE from the raw effect and the F value.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
interaction_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
interaction_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
interaction_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(n_participant)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df - 1,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## The lower boundary is 0

# Upper
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df - 1,
   meanoftheory = 0,
   sdtheory = 33,
   dftheory = 10^10,
   tail = 1)
```

### Outcome neutral test
#### Test Stroop effect

This is an outcome neutral test, therefore, the results of this test do not effect our main conclusions.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(n_participant)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 0.8,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 14510,
   dftheory = 10^10,
   tail = 1)
```

### Supporting test of interest
#### Test previous congruency effect

This is a supporting test of interest. We use the same prior as for the main Stroop effect test.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(n_participant)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 as the Bf is inconclusive

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 44,
   dftheory = 10^10,
   tail = 1)
```

### Accuracy analysis
#### Import data

```{r}
main_analysis_acc_data <-
  read_tsv("Data/Processed/Exp1/Kan_Processed_Exp1_Main_Acc_data.tsv")
```

#### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_acc_data %>% 
  group_by(participant_id) %>% 
  count()
```

The number of participants.

```{r}
main_analysis_acc_data %>% 
  distinct(participant_id) %>% 
  count()
```

#### The distribution of hit rates

Calculating the hit rate for each participant.

```{r}
main_analysis_acc_data %>% 
  group_by(participant_id) %>% 
  summarise(acc = mean(is_correct),
            hit_rate = acc * 100) %>% 
  arrange(acc) %>% 
  ggplot() +
  aes(x = hit_rate) %>% 
  geom_histogram()
```

#### Figures

The congruency sequence effect for the accuracy responses.

```{r}
kan_exp1_acc_cse_plot <-
  main_analysis_acc_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(participant_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(participant_mean_acc, na.rm = T),
            sd_acc = sd(participant_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_acc - (se_acc * 1.96),
                    ymax = mean_acc + (se_acc * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = c(.85, .4))

kan_exp1_acc_cse_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp1_Acc_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp1_acc_cse_plot)
```

#### Data preprocessing

We are calculating the accuracy for each condition (cc, ci, ic, ii) for each participant.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

We convert the predictor variables for the ANOVA to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id))
```

We are running the ANOVA described in the paper.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

We are converting the output of the ANOVA to tibble format.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_acc
```

We are extracting the F value and the df for each term in the ANOVA.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

We calculate the raw effects for each term for each participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect =  ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii))
```

We are aggregating the raw effects of the participants.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

We join the F value and Dfs to the raw effects for each term.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

From the raw effect and the F value we calculate the SE.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
interaction_se <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
interaction_effect <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
interaction_df <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df,
   meanoftheory = 0,
   sdtheory = .0095,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df,
   meanoftheory = 0,
   sdtheory = .28,
   dftheory = 10^10,
   tail = 1)
```

#### Arcsine transformed accuracy

We run the calculations with arcsine transformed proportions. We will include these findings in the supplementary materials.

The calculation is the same as before expect that we use arcsine transformation on the conditional means. We are going to use a formula describe in the original paper to calculate the arcsine transformed values, but we will also use a more common way to calculate the transformed values. Copying the whole accuracy analysis part would take up a lot of space in the code and would be error prone therefore, we created simple functions to calculate the Bf with the arcsine transformed data.

The method the original paper used to transform the raw proportions.

```{r}
arcsine_original_method <- quo(asin(( 2 * acc_conditional_mean) - 1))
```

A more common way to calculate.

```{r}
arcsine_common_method <- quo(asin(sqrt(acc_conditional_mean)))
```

Calculating the Bf with the two methods.

```{r}
arcsine_two_way(
  df = main_analysis_acc_data,
  expression = arcsine_original_method
  )

arcsine_two_way(
  df = main_analysis_acc_data,
  expression = arcsine_common_method
  )
```

__Note: The accuracy main effect of the current trial was not significant in the original study so we do not attempt to replicate it.__

### Supporting tests of interest

As the presence of the interaction effect in the accuracy analysis was supported by the Bayes factor we run further tests to investigate the CSE.

We run further comparisons to test whether congruency sequence effect modulated the performance on congruent, on incongruent trials or on both. To this aim, we test whether the type of the preceding trial modulates the accuracy rates of congruent and incongruent trials. To model the H1s, we utilize the parameters of the test of the interaction.

Comparing cC and iC trials.

```{r}
cong_prev <- 
  main_analysis_acc_participant_level_raw_effect %>% 
  t.test(.$cc, .$ic, paired = TRUE, alternative = "greater", data = .) %>% 
  broom::tidy()

cong_prev$estimate <- unname(cong_prev$estimate)
cong_prev$statistic <- unname(cong_prev$statistic)
cong_prev$parameter <- unname(cong_prev$parameter)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = abs(cong_prev$estimate / cong_prev$statistic),
   obtained = cong_prev$estimate,
   dfdata = cong_prev$parameter,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = abs(cong_prev$estimate / cong_prev$statistic),
   obtained = cong_prev$estimate,
   dfdata = cong_prev$parameter,
   meanoftheory = 0,
   sdtheory = .027,
   dftheory = 10^10,
   tail = 1)

# Upper
## Inf
```

Comparing iI and Ci trials.

```{r}
incong_prev <- 
  main_analysis_acc_participant_level_raw_effect %>% 
  t.test(.$ii, .$ci, paired = TRUE, alternative = "greater", data = .) %>% 
  broom::tidy()

incong_prev$estimate <- unname(incong_prev$estimate)
incong_prev$statistic <- unname(incong_prev$statistic)
incong_prev$parameter <- unname(incong_prev$parameter)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = abs(incong_prev$estimate / incong_prev$statistic),
   obtained = incong_prev$estimate,
   dfdata = incong_prev$parameter,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = abs(incong_prev$estimate / incong_prev$statistic),
   obtained = incong_prev$estimate,
   dfdata = incong_prev$parameter,
   meanoftheory = 0,
   sdtheory = .0036,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = abs(incong_prev$estimate / incong_prev$statistic),
   obtained = incong_prev$estimate,
   dfdata = incong_prev$parameter,
   meanoftheory = 0,
   sdtheory = 14.3,
   dftheory = 10^10,
   tail = 1)
```

***

# Exp 2
## Reaction time analysis
### Import data

```{r}
main_analysis_rt_data <-
  read_tsv("Data/Processed/Exp2/Kan_Processed_Exp2_Main_Rt_data.tsv")
```

### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  count(participant_id)
```

The number of participants.

```{r}
main_analysis_rt_data %>% 
  distinct(participant_id) %>% 
  count()
```

Comparing the descriptive statistics of the low and high reversal groups. These values are calculated from the mean number of reversals for each participant. The calculation based on trial level reversal times can be found in the **Kan_Raw_Processed** file.

```{r}
main_analysis_rt_data %>% 
  group_by(reversal_group) %>% 
  summarise(n = n(),
            all_mean_reversal = mean(mean_reversal),
            all_sd_reversal = sd(mean_reversal, na.rm = TRUE))
```

### Figures

The congruency sequence effect for the reaction time responses with reversal groups.

```{r}
kan_exp2_rt_cse_rev_plot <-
  main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent"),
         reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>%
  group_by(participant_id, reversal_group, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent, reversal_group) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - (se_rt * 1.96),
                    ymax = mean_rt + (se_rt * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time (ms)") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  facet_wrap( ~ reversal_group) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20),
        legend.position = c(.9, .3))

kan_exp2_rt_cse_rev_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Rt_Cse_Rev_Plot.png", width = 14.4, height = 8, plot = kan_exp2_rt_cse_rev_plot)
```

The congruency sequence effect for the reaction time responses without reversal groups.

```{r}
kan_exp2_rt_cse_plot <-
  main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - (se_rt * 1.96),
                    ymax = mean_rt + (se_rt * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time (ms)") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20))

kan_exp2_rt_cse_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Rt_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp2_rt_cse_plot)
```

### Crucial tests
### Two way interaction
#### Data preprocessing

We are calculating the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup()
```

Before the ANOVA we transform the predictor variables to factors.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
    mutate(is_congruent = as.factor(is_congruent),
           is_previous_congruent = as.factor(is_previous_congruent),
           participant_id = as.factor(participant_id))
```

The number of participants for the rt analysis.

```{r}
main_analysis_rt_aggregate %>% 
  distinct(participant_id) %>% 
  count()
```

We are running the ANOVA.

```{r}
anova_rt <-
  ezANOVA(data = main_analysis_rt_aggregate, dv = rt_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Transforming the results of the ANOVA to a datatable.

```{r}
anova_rt <-
  as_tibble(anova_rt$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_rt
```

Extracting the F value and df from the ANOVA.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating the raw effects per participant.

```{r}
main_analysis_rt_participant_level_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ii + ic) / 2) - ((ci + cc) / 2),
         interaction_effect = (ci - cc) - (ii - ic),
         prev_cong = ci - cc,
         prev_incon = ii - ic,
         current_incongruent = ci - ii)
```

We are calculating the mean raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T),
            prev_cong_mean = mean(prev_cong, na.rm = T),
            prev_incon_mean = mean(prev_incon, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

We are joining the F values and dfs with the raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

We are calculating the SE from the raw effect size and F value.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Assigning variables to calculate Bayes factor.

```{r}
# sd
rt_sd <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# obtained
rt_obtained <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# df
rt_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bf analysis.

```{r}
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 because it is inconclusive

# Upper
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 180,
   dftheory = 10^10,
   tail = 1)
```

### Outcome neutral test
#### Test Stroop effect

This is an outcome neutral test, therefore, the results of this test do not effect our main conclusions.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 0.69,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 16991,
   dftheory = 10^10,
   tail = 1)
```

### Supporting test of interest
#### Test previous congruency effect

This is a supporting test of interest. We use the same prior as for the main Stroop effect test.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 1.08,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 17280,
   dftheory = 10^10,
   tail = 1)
```

### Three way interaction
#### Data preprocessing

We are calculating the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup()
```

Before the ANOVA we transform the predictor variables to factors.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
    mutate(is_congruent = as.factor(is_congruent),
           is_previous_congruent = as.factor(is_previous_congruent),
           participant_id = as.factor(participant_id),
           reversal_group = as.factor(reversal_group))
```

The number of participants per reversal group.

```{r}
main_analysis_rt_aggregate %>% 
  group_by(reversal_group) %>% 
  count()
```

The number of participants for the rt analysis.

```{r}
main_analysis_rt_aggregate %>% 
  distinct(participant_id) %>% 
  count()
```

We are running the ANOVA.

```{r}
anova_rt <-
  ezANOVA(data = main_analysis_rt_aggregate, dv = rt_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), between = reversal_group, type = 3)
```

Transforming the results of the ANOVA to a datatable.

```{r}
anova_rt <-
  as_tibble(anova_rt$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_rt
```

Extracting the F value and df from the ANOVA.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "reversal_group:is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "reversal_group:is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating the raw effects per participant.

```{r}
main_analysis_rt_participant_level_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ii + ic) / 2) - ((ci + cc) / 2),
         interaction_effect = (ci - cc) - (ii - ic),
         prev_cong = ci - cc,
         prev_incon = ii - ic,
         current_incongruent = ci - ii)
```

We are calculating the mean raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_participant_level_raw_effect %>% 
  group_by(reversal_group) %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T),
            prev_cong_mean = mean(prev_cong, na.rm = T),
            prev_incon_mean = mean(prev_incon, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect", -reversal_group) %>%
  spread(key = "reversal_group", value = "raw_effect")
```

We are extracting the low raw effect sizes from the high raw effect sizes according to the hypothesis.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  ungroup() %>% 
  mutate(raw_effect = high - low) %>% 
  select(-high,
         -low)
```

We are joining the F values and dfs with the raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

We are calculating the se from the raw effect size and f value.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Assigning variables to calculate bayes factor.

```{r}
# sd
rt_sd <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# obtained
rt_obtained <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# df
rt_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bf analysis.

```{r}
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 24.3,
   dftheory = 10^10,
   tail = 1)

# Upper
## Inf
```

### Correlation

We are calculating the correlation between the mean number of reversals per participant and the size of the conflict adaptation operationalized by the current incongruent difference.

First we create a dataset for the comparison.

```{r}
main_analysis_rt_cor_data <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group, mean_reversal) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(current_incongruent = ci - ii) %>% 
  select(participant_id,
         current_incongruent,
         mean_reversal,
         reversal_group)
```

We are visualizing the comparison on a figure.

```{r}
kan_exp2_correlation_rt_plot <-
  main_analysis_rt_cor_data %>%  
  mutate(reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>% 
  ggplot() +
  aes(x = mean_reversal,
      y = current_incongruent,
      fill = reversal_group) +
  geom_jitter(colour = "black", pch = 21, size = 3) +
  guides(shape = guide_legend(title = "Reversal group")) +
  labs(x = "The mean number of reversals",
       y = "The conflict adaptation effect (cI - iI) in milliseconds",
       fill = "Reversel group") +
  viridis::scale_fill_viridis(discrete = TRUE) +
  theme_minimal() +
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        legend.position = c(.9, .3))

kan_exp2_correlation_rt_plot
```

Save the plot.

```{r}
ggsave("Figures/Kan_Exp2_Correlation_Rt_Plot.png", width = 14.4, height = 8, plot = kan_exp2_correlation_rt_plot)
```

Running the correlation.

```{r}
cor.test(main_analysis_rt_cor_data$current_incongruent,
         main_analysis_rt_cor_data$mean_reversal,
         method = "pearson")
```

## Accuracy analysis
### Importing data

```{r}
main_analysis_acc <- read_tsv("Data/Processed/Exp2/Kan_Processed_Exp2_Main_Acc_data.tsv")
```

### Exploratory data analysis

The number of trials per participant.

```{r}
main_analysis_acc %>% 
  group_by(participant_id) %>% 
  count()
```

The number of participants.

```{r}
main_analysis_acc %>% 
  distinct(participant_id) %>% 
  count()
```

The number and frequency of correct trials. There are different number of trials per participant because each participant was assigned to a different set of trails (out of 6) randomly. These sets contained different number  of test trials that satisfy the criteria to be the part of the analysis.

```{r}
main_analysis_acc %>% 
  group_by(participant_id, is_correct) %>% 
  count() %>% 
  group_by(participant_id) %>% 
  mutate(sum_n = sum(n),
         freq = n / sum_n * 100) %>%
  filter(is_correct == 1L)
```

### Figures

Figure with reversal groups.

```{r}
kan_exp2_acc_cse_rev_plot <-
  main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent"),
         reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>%
  group_by(is_previous_congruent, is_congruent, reversal_group, participant_id) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent, reversal_group) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - (se_acc * 1.96),
                    ymax = mean_acc + (se_acc * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  facet_wrap( ~ reversal_group) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))

kan_exp2_acc_cse_rev_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Acc_Cse_Rev_Plot.png", width = 14.4, height = 8, plot = kan_exp2_acc_cse_rev_plot)
```

Figure without reversal groups.

```{r}
kan_exp2_acc_cse_plot <-
  main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - (se_acc * 1.96),
                    ymax = mean_acc + (se_acc * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))

kan_exp2_acc_cse_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Acc_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp2_acc_cse_plot)
```

### Crucial tests
### Two way interaction
#### Data preprocessing

we are calculating the conditional mean of the correct trials per participant and per condition (CC, II, CI, IC).

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

Transfer independent variables used in the ANOVA to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id))
```

Running the mixed ANOVA.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Transforming the output of the ANOVA to a tibble.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_acc
```

Extract the F value and df2 from the ANOVA.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

We calculate the raw effects per participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii),
         current_incongruent = ii - ci)
```

We summarize the participant level data for further analysis.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

We join the calculated raw effects with the F value and the df from the ANOVA.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

We valvulate the SE corresponding to the raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Saving values needed for the Bayes factor analysis.

```{r}
# SE
acc_sd <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Raw effect
acc_obtained <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Degrees of freedom
acc_df <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Calculating the Bayes factor.

```{r}
Bf(sd = acc_sd,
   obtained = acc_obtained,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 because it is inconclusive

# Upper
Bf(sd = acc_sd,
   obtained = acc_obtained,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .049,
   dftheory = 10^10,
   tail = 1)
```

#### Arcsine transformed accuracy

Calculating the Bf with the two methods.

```{r}
arcsine_two_way(
  df = main_analysis_acc,
  expression = arcsine_original_method
  )

arcsine_two_way(
  df = main_analysis_acc,
  expression = arcsine_common_method
  )
```

### Three way interaction
#### Data preprocessing

We are calculating the conditional mean of the correct trials per participant and per condition (CC, II, CI, IC).

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc %>% 
  group_by(participant_id, reversal_group, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

The number of participants in each reversal group.

```{r}
main_analysis_acc_aggregate %>% 
  distinct(participant_id, .keep_all = T) %>% 
  group_by(reversal_group) %>% 
  count()
```

Transfer independent variables used in the ANOVA to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id),
         reversal_group = as_factor(reversal_group))
```

Running the mixed ANOVA.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), between = reversal_group, type = 3)
```

Transforming the output of the ANOVA to a tibble.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_acc
```

Extract the F value and df2 from the ANOVA.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "reversal_group:is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "reversal_group:is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

We calculate the raw effects per participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii),
         current_incongruent = ii - ci)
```

We summarise the participant level data for further analysis.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  group_by(reversal_group) %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect", -reversal_group) %>%
  spread(key = "reversal_group", value = "raw_effect")
```

We calculate the differences of the effects between the low and high reversal group. We extract the high reversal group raw effect from the low reversal group effect because according to the theory the high group experienced greater conflict, therefore the CSE should be stronger there.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  ungroup() %>% 
  mutate(raw_effect = high - low) %>% 
  select(-high,
         -low)
```

We join the calculated raw effects with the F value and the df from the ANOVA.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

We valvulate the SE corresponding to the raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Saving values needed for the Bayes factor analysis.

```{r}
# SE
acc_sd <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Raw effect
acc_obtained <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Degrees of freedom
acc_df <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Calculating the Bayes factor.

```{r}
Bf(sd = acc_sd,
   obtained = acc_obtained,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 because inconclusive

# Upper
Bf(sd = acc_sd,
   obtained = acc_obtained,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .045,
   dftheory = 10^10,
   tail = 1)
```

#### Arcsine transformed accuracy

We run the calculations with arcsine transformed proportions. We will include these findings in the supplementary materials.

The calculation is the same as before expect that we use arcsine transformation on the conditional means.

```{r}
arcsine_three_way(
  df = main_analysis_acc,
  expression = arcsine_original_method
  )

arcsine_three_way(
  df = main_analysis_acc,
  expression = arcsine_common_method
  )
```

### Correlation

Creating dataset for the comparison between the mean number of experienced reversals and the raw interaction effect per participant.

```{r}
main_analysis_acc_cor <-
  main_analysis_acc %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group, mean_reversal) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(current_incongruent = ii - ci) %>% 
  select(participant_id,
         current_incongruent,
         mean_reversal,
         reversal_group)
```

Visualizing the correlation on a figure.

```{r}
kan_exp2_correlation_acc_plot <-
  main_analysis_acc_cor %>%  
  mutate(reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>% 
  ggplot() +
  aes(x = mean_reversal,
      y = current_incongruent,
      fill = reversal_group) +
  geom_jitter(colour="black", pch=21, size = 3) +
  guides(shape = guide_legend(title = "Reversal group")) +
  labs(x = "The mean number of reversals",
       y = "The conflict adaptation effect (II - CI) frequency of correct trials",
       fill = "Reversel group") +
  viridis::scale_fill_viridis(discrete = TRUE) +
  theme_minimal() +
  theme(axis.title = element_text(size = 15),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        legend.position = c(.9, .4))

kan_exp2_correlation_acc_plot
```

Save the plot.

```{r}
ggsave("Figures/Kan_Exp2_Correlation_Acc_Plot.png", width = 14.4, height = 8, plot = kan_exp2_correlation_acc_plot)
```

Running the correlation test.

```{r}
cor.test(main_analysis_acc_cor$current_incongruent,
         main_analysis_acc_cor$mean_reversal,
         method = "pearson")
```

***

# Exp 3
## Reaction time analysis
### Import data

```{r}
main_analysis_rt_data <-
  read_tsv("Data/Processed/Exp3/Kan_Processed_Exp3_Main_Rt_data.tsv")
```

### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  group_by(participant_id) %>% 
  count()
```

The number of participants.

```{r}
main_analysis_rt_data %>% 
  distinct(participant_id) %>% 
  count()
```

### Figures

The congruency sequence effect for the reaction time responses.

```{r}
kan_exp3_rt_cse_plot <-
  main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - (se_rt * 1.96),
                    ymax = mean_rt + (se_rt * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time (ms)") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20),
        legend.position = c(.9, .8))

kan_exp3_rt_cse_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp3_Rt_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp3_rt_cse_plot)
```

### Crucial tests
#### Data preprocessing

We are calculating the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup()
```

Before the ANOVA we transform the predictor variables to factors.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
    mutate(is_congruent = as.factor(is_congruent),
           is_previous_congruent = as.factor(is_previous_congruent),
           participant_id = as.factor(participant_id))
```

We are running the ANOVA.

```{r}
anova_rt <-
  ezANOVA(data = main_analysis_rt_aggregate, dv = rt_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Transforming the results of the ANOVA to a datatable.

```{r}
anova_rt <-
  as_tibble(anova_rt$ANOVA)
```

Show the results of the ANOVA.

```{r}
anova_rt
```

Extracting F value and df from the ANOVA.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating the raw effects per participant.

```{r}
main_analysis_rt_participant_level_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ii + ic) / 2) - ((ci + cc) / 2),
         interaction_effect = (ci - cc) - (ii - ic),
         prev_cong = ci - cc,
         prev_incon = ii - ic,
         current_incongruent = ci - ii)
```

Summarizing the mean raw effects.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>% 
  gather(key = "term", value = "raw_effect")
```

Joining the raw effects with the F value and df.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

Calculating SE.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
rt_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
rt_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
rt_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bayes factor analysis.

```{r}
Bf(sd = rt_se,
   obtained = rt_effect,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 because it was inconclusive

# Upper
Bf(sd = rt_se,
   obtained = rt_effect,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 32,
   dftheory = 10^10,
   tail = 1)
```

### Outcome neutral test
#### Test Stroop effect

This is an outcome neutral test, therefore, the results of this test do not effect our main conclusions.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 1.5,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 15800,
   dftheory = 10^10,
   tail = 1)
```

### Supporting test of interest
#### Test previous congruency effect

This is a supporting test of interest. We use the same prior as for the main Stroop effect test.

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_previous_congruent") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 1.8,
   dftheory = 10^10,
   tail = 1)

# Upper
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df,
   meanoftheory = 0,
   sdtheory = 27740,
   dftheory = 10^10,
   tail = 1)
```

## Accuracy analysis
### Importing data

```{r}
main_analysis_acc <- read_tsv("Data/Processed/Exp3/Kan_Processed_Exp3_Main_Acc_data.tsv")
```

### Exploratory data analysis

The number and frequency of correct trials.

```{r}
main_analysis_acc %>% 
  group_by(participant_id, is_correct) %>% 
  count() %>% 
  group_by(participant_id) %>% 
  mutate(sum_n = sum(n),
         freq = n / sum_n * 100) %>%
  filter(is_correct == 1L)
```

The number of participants.

```{r}
main_analysis_acc %>% 
  distinct(participant_id) %>% 
  count()
```

### Figures

Congruency sequence effect of accuracy.

```{r}
kan_exp3_acc_congruency_plot <-
  main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - (se_acc * 1.96),
                    ymax = mean_acc + (se_acc * 1.96)),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))

kan_exp3_acc_congruency_plot
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp3_Acc_Cse_Plot.png", width = 14.4, height = 8, plot = kan_exp3_acc_congruency_plot)
```

### Data preprocessing

Calculating the mean accuracy for each participant in each condition.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

Transforming grouping variables to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id))
```

Running the ANOVA.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Show the results of the ANOVA.

```{r}
anova_acc
```

Transforming the results of the ANOVA to a datatable.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Extracting F value and df.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating raw effects for each participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii),
         current_incongruent = ii - ci)
```

Summarizing mean raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

Joining F values and dfs and raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

Calculating SE.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
acc_se <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
acc_effect <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
acc_df <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bayes factor analysis.

```{r}
Bf(sd = acc_se,
   obtained = acc_effect,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

Robustness region.

```{r}
# Lower
## 0 because it is inconclusive

# Upper
Bf(sd = acc_se,
   obtained = acc_effect,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .28,
   dftheory = 10^10,
   tail = 1)
```

#### Arcsine transformed accuracy

We run the calculations with arcsine transformed proportions. We will include these findings in the supplementary materials.

The calculation is the same as before expect that we use arcsine transformation on the conditional means.

```{r}
arcsine_two_way(
  df = main_analysis_acc,
  expression = arcsine_original_method
  )

arcsine_two_way(
  df = main_analysis_acc,
  expression = arcsine_common_method
  )
```

