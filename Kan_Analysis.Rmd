---
title: "Kan_Analysis"
author: "Marton Kovacs"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: html_document
---

# Load packages

```{r}
library(tidyverse)
library(osfr)
library(readxl)
library(readbulk)
library(ez)
library(psych)
```

# Load custom functions

```{r}
source("utils.R")
```

# Exp1
## Crucial tests
### Reaction time analysis
#### Import data

```{r}
main_analysis_rt_data <-
  read_tsv("Data/Processed/Exp1/Kan_Processed_Exp1_Main_Rt_data.tsv")
```

#### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  group_by(participant_id) %>% 
  count()
```

#### Figures

The congruency sequency effect for the reaction time responses.

```{r}
main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(participant_mean_rt = mean(response_time, na.rm = T)) %>%
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(participant_mean_rt, na.rm = T),
            sd_rt = sd(participant_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>% 
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - se_rt,
                    ymax = mean_rt + se_rt),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = c(.85, .4))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp1_Rt_Congruency_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

#### Data preprocessing

We are calucalting the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup() %>% 
  mutate(is_congruent = as.factor(is_congruent),
         is_previous_congruent = as.factor(is_previous_congruent),
         participant_id = as.factor(participant_id))
```

The number of conditions per participant. Because we excluded the incorrect trials, it can happen that a participant does no have reeaction time responses from all the 4 conditions.

```{r}
main_analysis_rt_aggregate %>% 
  group_by(participant_id) %>% 
  count() %>% 
  arrange(n)
```

Save the [participant_id] of those participants who do not have data from all the four conditions.

```{r}
missing_condition <-
  main_analysis_rt_aggregate %>% 
  group_by(participant_id) %>% 
  count() %>% 
  filter(n != 4) %>%
  select(participant_id)
```

The number of participants who has missing conditions.

```{r}
missing_condition %>%
  ungroup() %>% 
  count()
```

Excluding these participants from further analysis.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
  anti_join(., missing_condition, by = "participant_id")
```

Calucalting the raw congruency, previous congruency and interaction effect for each participant.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (ci - cc) - (ii - ic))
```

Running the repeated measure ANOVA.

```{r}
anova_rt <-
  aov(rt_conditional_mean ~ is_congruent * is_previous_congruent + Error(participant_id / (is_congruent * is_previous_congruent)), data = main_analysis_rt_aggregate)
```

Saving the F value and Df for each effect of interest.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  broom::tidy() %>% 
  select(term, statistic) %>% 
  transmute(term = case_when(term == "is_congruent" ~ "main_effect_is_congruent",
                             term == "is_previous_congruent" ~ "main_effect_is_previous_congruent",
                             term == "is_congruent:is_previous_congruent" ~ "interaction_effect",
                             term == "Residuals" ~ term),
            f_value = statistic) %>% 
  filter(!is.na(f_value))
```

Calculating the raw effects summarized for every participant.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  summarise(main_effect_is_congruent = mean(congruency_effect, na.rm = T),
            main_effect_is_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T),
            n_participant = n()) %>%
  gather(key = "term", value = "raw_effect", -n_participant)
```

Joining the calculated F values and Dfs with the raw effects.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

Caclulating the SE from the raw effect and the F value.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
interaction_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
interaction_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
interaction_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(n_participant)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df - 1,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

#### Testing the results

In order to test the result of the ANOVA we are calculating the F value from a t value.

```{r}
# (ci -cc) - (ii-ic)
# (ci + ii / 2) - (cc + ic / 2)
```

### Accuracy analysis
#### Import data

```{r}
main_analysis_acc_data <-
  read_tsv("Data/Processed/Exp1/Kan_Processed_Exp1_Main_Acc_data.tsv")
```

#### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_acc_data %>% 
  group_by(participant_id) %>% 
  count()
```

#### The distribution of hit rates

Caculating the hit rate for each participant.

```{r}
main_analysis_acc_data %>% 
  group_by(participant_id) %>% 
  summarise(acc = mean(is_correct),
            hit_rate = acc * 100) %>% 
  arrange(acc) %>% 
  ggplot() +
  aes(x = hit_rate) %>% 
  geom_histogram()
```

#### Figures

The congruency sequency effect for the accuracy responses.

```{r}
main_analysis_acc_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(participant_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(participant_mean_acc, na.rm = T),
            sd_acc = sd(participant_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_acc - se_acc,
                    ymax = mean_acc + se_acc),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        legend.position = c(.85, .4))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp1_Acc_Congruency_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

#### Data preprocessing

We are calculating the accuracy for each condition (cc, ci, ic, ii) for each participant.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

We convert the predictor variables for the ANOVA to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id))
```

We are running the ANOVA described in the paper.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

We are converting the output of the ANOVA to tibble format.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

We are extracting the F value and the df for each term in the ANOVA.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

We caluclate the raw effects for each term for each participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii))
```

We are aggregating the raw effects of the participants.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

We join the F value and Dfs to the raw effects for each term.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

From the raw effect and the F value we calculate the SE.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = raw_effect / sqrt(f_value))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
interaction_se <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
interaction_effect <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
interaction_df <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = interaction_se,
   obtained = interaction_effect,
   dfdata = interaction_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

## outcome neutral test
### Test Stroop effect

Saving the values needed for the analysis.

```{r}
# Obtained sd
main_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(se)

# Obtained effect
main_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(raw_effect)

# Df
main_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "main_effect_congruent") %>% 
  pull(n_participant)
```

Running the Bf analysis with the model described in the paper.

```{r}
Bf(sd = main_se,
   obtained = main_effect,
   dfdata = main_df - 1,
   meanoftheory = 0,
   sdtheory = 28,
   dftheory = 10^10,
   tail = 1)
```

### Test sentence reading time
#### Import data

```{r}
outcome_neutral_sentence_data <- read_tsv("Data/Processed/Exp1/Kan_Processed_Exp1_OutcomeNeutral_Sentence_data.tsv")
```

#### Nest the data

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  nest(data = c(participant_id, Congruent, Incongruent))
```

#### Performing the t-tests

We calculate the t test for each sentence region separately.

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  mutate(t_value = map_dbl(data,
                       ~ t.test(.$Congruent, .$Incongruent, paired = TRUE, alternative = "less") %>% 
                         broom::tidy() %>% 
                         pull(statistic)),
         df = map_dbl(data,
                       ~ t.test(.$Congruent, .$Incongruent, paired = TRUE, alternative = "less") %>% 
                         broom::tidy() %>% 
                         pull(parameter)),
         p_value = map_dbl(data,
                       ~ t.test(.$Congruent, .$Incongruent, paired = TRUE, alternative = "less") %>% 
                         broom::tidy() %>% 
                         pull(p.value)),
         raw_effect = map_dbl(data,
                       ~ t.test(.$Congruent, .$Incongruent, paired = TRUE, alternative = "less") %>% 
                         broom::tidy() %>% 
                         pull(estimate)))
```

#### Calculating the SE

```{r}
outcome_neutral_sentence_data <-
  outcome_neutral_sentence_data %>% 
  mutate(se = map2_dbl(t_value, raw_effect,
                       ~ abs(.x / .y)))
```

#### Calculating the Bayes factor

We are calculating the Bf for only the temporarly ambiguous and disambiguating region.

```{r}
temp_ambig <- 
  outcome_neutral_sentence_data %>% 
  filter(sentence_region_type == "temporarly ambiguous")

disambig <- 
  outcome_neutral_sentence_data %>% 
  filter(sentence_region_type == "disambiguating ambiguous")
```

Creating a plots to visualize the difference.

```{r}
temp_ambig %>% 
  unnest(data) %>%
  select(Congruent, Incongruent) %>% 
  gather(key = "congruency", value = "resid_mean_reading_time") %>%  
  group_by(congruency) %>% 
  summarise(n = n(),
            mean = mean(resid_mean_reading_time),
            sd = sd(resid_mean_reading_time, na.rm = T),
            se = sd / sqrt(n)) %>% 
  ggplot() +
  aes(x = congruency,
      y = mean) +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean - se,
                    ymax = mean + se),
                width = .1) +
  xlab("Congruency of the sentence region")+
  ylab("Mean residual reading time") +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        strip.text.x = element_text(size = 20))
```

Assignig variables to calculate bayes factor for the temporarly ambiguous region.

```{r}
# sd
rt_sd <- 
  temp_ambig %>% 
  pull(se)

# obtained
rt_obtained <- 
  temp_ambig %>% 
  pull(raw_effect)

# df
rt_df <- 
  temp_ambig %>% 
  pull(df)
```

Running the Bf analysis for the temporarly ambiguous region.

```{r}
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 40,
   dftheory = 10^10,
   tail = 1)
```

Creating a plots to visualize the difference.

```{r}
disambig %>% 
  unnest(data) %>%
  select(Congruent, Incongruent) %>% 
  gather(key = "congruency", value = "resid_mean_reading_time") %>%  
  group_by(congruency) %>% 
  summarise(n = n(),
            mean = mean(resid_mean_reading_time),
            sd = sd(resid_mean_reading_time, na.rm = T),
            se = sd / sqrt(n)) %>% 
  ggplot() +
  aes(x = congruency,
      y = mean) +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean - se,
                    ymax = mean + se),
                width = .1) +
  xlab("Congruency of the sentence region")+
  ylab("Mean residual reading time") +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        strip.text.x = element_text(size = 20))
```

Assignig variables to calculate bayes factor for the disambiguating region.

```{r}
# sd
rt_sd <- 
  disambig %>% 
  pull(se)

# obtained
rt_obtained <- 
  disambig %>% 
  pull(raw_effect)

# df
rt_df <- 
  disambig %>% 
  pull(df)
```

Running the Bf analysis for the disambiguating region.

```{r}
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 18,
   dftheory = 10^10,
   tail = 1)
```

***

# Exp 2
## Reaction time analysis
### Import data

```{r}
main_analysis_rt_data <-
  read_tsv("Data/Processed/Exp2/Kan_Processed_Exp2_Main_Rt_data.tsv")
```

### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  group_by(participant_id) %>% 
  count()
```

### Figures

The congruency sequency effect for the reaction time responses with reversal groups.

```{r}
main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent"),
         reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>%
  group_by(participant_id, reversal_group, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent, reversal_group) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - se_rt,
                    ymax = mean_rt + se_rt),
                width=.1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  facet_wrap( ~ reversal_group) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20),
        legend.position = c(.9, .3))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Cse_Rev_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

The congruency sequency effect for the reaction time responses.

```{r}
main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - se_rt,
                    ymax = mean_rt + se_rt),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Cse_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

### Crucial tests
#### Data preprocessing

We are calucalting the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup()
```

Before the ANOVA we transform the predictor variables to factors.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
    mutate(is_congruent = as.factor(is_congruent),
           is_previous_congruent = as.factor(is_previous_congruent),
           participant_id = as.factor(participant_id),
           reversal_group = as.factor(reversal_group))
```

The number of participants per reversal group.

```{r}
main_analysis_rt_aggregate %>% 
  group_by(reversal_group) %>% 
  count()
```

The number of participants for the rt analysis.

```{r}
main_analysis_rt_aggregate %>% 
  distinct(participant_id) %>% 
  count()
```

We are running the ANOVA.

```{r}
anova_rt <-
  ezANOVA(data = main_analysis_rt_aggregate, dv = rt_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), between = reversal_group, type = 3)
```

Transfroming the results of the ANOVA to a datatable.

```{r}
anova_rt <-
  as_tibble(anova_rt$ANOVA)
```

Extracting the F value and df from the ANOVA.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "reversal_group:is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "reversal_group:is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating the raw effects per participant.

```{r}
main_analysis_rt_participant_level_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ii + ic) / 2) - ((ci + cc) / 2),
         interaction_effect = (ci - cc) - (ii - ic),
         prev_cong = ci - cc,
         prev_incon = ii - ic,
         current_incongruent = ci - ii)
```

We are calculating the mean raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_participant_level_raw_effect %>% 
  group_by(reversal_group) %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T),
            prev_cong_mean = mean(prev_cong, na.rm = T),
            prev_incon_mean = mean(prev_incon, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect", -reversal_group) %>%
  spread(key = "reversal_group", value = "raw_effect")
```

We are extracting the low raw effect sizes from the high raw effect sizes according to the hypothesis.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  ungroup() %>% 
  mutate(raw_effect = high - low) %>% 
  select(-high,
         -low)
```

We are joining the F values and dfs with the raw effect sizes.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

We are calculating the se from the raw effect size and f value.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Assignig variables to calculate bayes factor.

```{r}
# sd
rt_sd <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# obtained
rt_obtained <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# df
rt_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bf analysis.

```{r}
Bf(sd = rt_sd,
   obtained = rt_obtained,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

### Correlation

We are calculating the correlation between the mean number of reversals per participant and the size of the conflict adaptation operationalized by the current incongruent difference.

First we create a dataset for the comparison.

```{r}
main_analysis_rt_cor_data <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group, mean_reversal) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(current_incongruent = ci - ii) %>% 
  select(participant_id,
         current_incongruent,
         mean_reversal,
         reversal_group)
```

We are visualizing the comparison on a figure.

```{r}
main_analysis_rt_cor_data %>%  
  mutate(reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>% 
  ggplot() +
  aes(x = mean_reversal,
      y = current_incongruent,
      fill = reversal_group) +
  geom_jitter(colour = "black", pch = 21, size = 3) +
  guides(shape = guide_legend(title = "Reversal group")) +
  labs(x = "The mean number of reversals",
       y = "The conflict adaptation effect (II - CI) in milliseconds",
       fill = "Reversel group") +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        legend.position = c(.9, .3))
```

Running the correlation.

```{r}
cor.test(main_analysis_rt_cor_data$current_incongruent,
         main_analysis_rt_cor_data$mean_reversal,
         method = "pearson")
```

## Accuracy analysis
### Importing data

```{r}
main_analysis_acc <- read_tsv("Data/Processed/Exp2/Kan_Processed_Exp2_Main_Acc_data.tsv")
```

### Exploratory data analysis

The number of trials per participant.

```{r}
main_analysis_acc %>% 
  group_by(participant_id) %>% 
  count()
```

The number and frequency of correct trials. There are different number of trials per participant because each participant was assigned to a different set of trails (out of 6) randomly. These sets contained different number  of test trials that satisfy the criteria to be the part of the analysis.

```{r}
main_analysis_acc %>% 
  group_by(participant_id, is_correct) %>% 
  count() %>% 
  group_by(participant_id) %>% 
  mutate(sum_n = sum(n),
         freq = n / sum_n * 100) %>%
  filter(is_correct == 1L)
```

### Figures

Figure with reversal groups.

```{r}
main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent"),
         reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>%
  group_by(is_previous_congruent, is_congruent, reversal_group, participant_id) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent, reversal_group) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>% View()
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - se_acc,
                    ymax = mean_acc + se_acc),
                width=.1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  facet_wrap( ~ reversal_group) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Acc_Cse_Rev_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

Figure without reversal groups.

```{r}
main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - se_acc,
                    ymax = mean_acc + se_acc),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp2_Acc_Cse_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

### Crucial tests
#### Data preprocessing

we are calculating the conditional mean of the correct trials per particpant and per condition (CC, II, CI, IC).

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc %>% 
  group_by(participant_id, reversal_group, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

The number of participants in each reversal group.

```{r}
main_analysis_acc_aggregate %>% 
  distinct(participant_id, .keep_all = T) %>% 
  group_by(reversal_group) %>% 
  count()
```

Transfer independent variables used in the ANOVA to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id),
         reversal_group = as_factor(reversal_group))
```

Running the mixed ANOVA.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), between = reversal_group, type = 3)
```

Transfroming the output of the ANOVA to a tibble.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Extract the F valu and df2 from the ANOVA.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "reversal_group:is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "reversal_group:is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

We calculate the raw effects per participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii),
         current_incongruent = ii - ci)
```

We summarise the participant level data for further analysis.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  group_by(reversal_group) %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect", -reversal_group) %>%
  spread(key = "reversal_group", value = "raw_effect")
```

We calculate the differences of the effects between the low and high reversal group. We extract the high reversal group raw effect from the low reversal group effect because according to the theory the high group experienced greater conflict, therefore the CSE should be stronger there.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  ungroup() %>% 
  mutate(raw_effect = high - low) %>% 
  select(-high,
         -low)
```

We join the calculated raw effects with the F value and the df from the ANOVA.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

We valvulate the SE corresponding to the raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

Saving values needed for the Bayes factor analysis.

```{r}
# SE
acc_sd <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Raw effect
acc_obtained <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Degrees of freedom
acc_df <-
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Calculating the Bayes factor.

```{r}
Bf(sd = acc_sd,
   obtained = acc_obtained,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```

### Correlation

Creating dataset for the comparison between the mean number of experienced reversals and the raw interaction effect per participant.

```{r}
main_analysis_acc_cor <-
  main_analysis_acc %>% 
  group_by(participant_id, is_congruent, is_previous_congruent, reversal_group, mean_reversal) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(current_incongruent = ci - ii) %>% 
  select(participant_id,
         current_incongruent,
         mean_reversal,
         reversal_group)
```

Cisualizing the correlation on a figure.

```{r}
main_analysis_acc_cor %>%  
  mutate(reversal_group = case_when(reversal_group == "low" ~ "Low reversal group",
                                    reversal_group == "high" ~ "High reversal group")) %>% 
  ggplot() +
  aes(x = mean_reversal,
      y = current_incongruent,
      fill = reversal_group) +
  geom_jitter(colour="black", pch=21, size = 3) +
  guides(shape = guide_legend(title = "Reversal group")) +
  labs(x = "The mean number of reversals",
       y = "The conflict adaptation effect (II - CI) frequency of correct trials",
       fill = "Reversel group") +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        legend.position = c(.9, .4))
```

Running the correlction test.

```{r}
cor.test(main_analysis_acc_cor$current_incongruent,
         main_analysis_acc_cor$mean_reversal,
         method = "pearson")
```

***

# Exp3
## Reaction time analysis
### Import data

```{r}
main_analysis_rt_data <-
  read_tsv("Data/Processed/Exp3/Kan_Processed_Exp3_Main_Rt_data.tsv")
```

### Exploratory data analysis

The number of response per participant.

```{r}
main_analysis_rt_data %>% 
  group_by(participant_id) %>% 
  count()
```

The number of participants.

```{r}
main_analysis_rt_aggregate %>% 
  distinct(participant_id) %>% 
  count()
```

### Figures

The congruency sequency effect for the reaction time responses.

```{r}
main_analysis_rt_data %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_rt = mean(response_time, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_rt = mean(par_mean_rt, na.rm = T),
            sd_rt = sd(par_mean_rt, na.rm = T),
            se_rt = sd_rt / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y = mean_rt,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 6) +
  geom_errorbar(aes(ymin = mean_rt - se_rt,
                    ymax = mean_rt + se_rt),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Reaction time") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 25),
        axis.text = element_text(size = 20),
        legend.text = element_text(size = 20),
        legend.title = element_text(size = 20),
        strip.text.x = element_text(size = 20))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp3_Rt_Cse_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

### Crucial tests
#### Data preprocessing

We are calucalting the mean reaction time per participant per condition (ci, ic, cc, ii).

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_data %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(rt_conditional_mean = mean(response_time, na.rm = T)) %>%
  ungroup()
```

Before the ANOVA we transform the predictor variables to factors.

```{r}
main_analysis_rt_aggregate <-
  main_analysis_rt_aggregate %>%
    mutate(is_congruent = as.factor(is_congruent),
           is_previous_congruent = as.factor(is_previous_congruent),
           participant_id = as.factor(participant_id))
```

We are running the ANOVA.

```{r}
anova_rt <-
  ezANOVA(data = main_analysis_rt_aggregate, dv = rt_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Transforming the results of the ANOVa to a datatable.

```{r}
anova_rt <-
  as_tibble(anova_rt$ANOVA)
```

Extracting F value and df from the ANOVA.

```{r}
anova_rt_f_value <-
  anova_rt %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating the raw effects per participant.

```{r}
main_analysis_rt_participant_level_raw_effect <-
  main_analysis_rt_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = rt_conditional_mean) %>% 
  mutate(congruency_effect = ((ci + ii) / 2) - ((cc + ic) / 2),
         previous_congruency_effect = ((ii + ic) / 2) - ((ci + cc) / 2),
         interaction_effect = (ci - cc) - (ii - ic),
         prev_cong = ci - cc,
         prev_incon = ii - ic,
         current_incongruent = ci - ii)
```

Summarizing the mean raw effects.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>% 
  gather(key = "term", value = "raw_effect")
```

Joining the raw effects with the F value and df.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>%
  inner_join(., anova_rt_f_value, by = "term")
```

Calculating se.

```{r}
main_analysis_rt_raw_effect <-
  main_analysis_rt_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
rt_se <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
rt_effect <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
rt_df <- 
  main_analysis_rt_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bayes factor analysis.

```{r}
Bf(sd = rt_se,
   obtained = rt_effect,
   dfdata = rt_df,
   meanoftheory = 0,
   sdtheory = 30,
   dftheory = 10^10,
   tail = 1)
```

## Accuracy analysis
### Importing data

```{r}
main_analysis_acc <- read_tsv("Data/Processed/Exp3/Kan_Processed_Exp3_Main_Acc_data.tsv")
```

### Exploratory data analysis

The number and frequency of correct trials.

```{r}
main_analysis_acc %>% 
  group_by(participant_id, is_correct) %>% 
  count() %>% 
  group_by(participant_id) %>% 
  mutate(sum_n = sum(n),
         freq = n / sum_n * 100) %>%
  filter(is_correct == 1L) %>% View()
```

The number of participants.

```{r}
main_analysis_acc %>% 
  distinct(participant_id) %>% 
  count()
```

### Figures

Congruency sequence effect of accuracy.

```{r}
main_analysis_acc %>% 
  mutate(is_previous_congruent = case_when(is_previous_congruent ==  0L ~ "Incongruent",
                                           is_previous_congruent ==  1L ~ "Congruent"),
         is_congruent = case_when(is_congruent ==  0L ~ "Incongruent",
                                  is_congruent ==  1L ~ "Congruent")) %>%
  group_by(participant_id, is_previous_congruent, is_congruent) %>% 
  summarise(par_mean_acc = mean(is_correct, na.rm = T)) %>% 
  group_by(is_previous_congruent, is_congruent) %>% 
  summarise(N = n(),
            mean_acc = mean(par_mean_acc, na.rm = T),
            sd_acc = sd(par_mean_acc, na.rm = T),
            se_acc = sd_acc / sqrt(N)) %>%
  ggplot() +
  aes(x = is_previous_congruent,
      y =  mean_acc,
      shape = is_congruent,
      group = is_congruent) +
  geom_path() +
  geom_point(size = 4) +
  geom_errorbar(aes(ymin = mean_acc - se_acc,
                    ymax = mean_acc + se_acc),
                width = .1) +
  guides(color = FALSE) +
  xlab("Congruency of the previous trial")+
  ylab("Accuracy") +
  guides(shape = guide_legend(title = "Congruency of \n the current trial")) +
  theme_minimal() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 15),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15),
        strip.text.x = element_text(size = 15),
        legend.position = c(.9, .8))
```

Saving the figure.

```{r}
ggsave("Figures/Kan_Exp3_Acc_Congruency_Plot.png", width = 14.4, height = 8, plot = last_plot())
```

### Data preprocessing

Calculating the mean accuracy for each participant in each condition.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc %>% 
  group_by(participant_id, is_congruent, is_previous_congruent) %>% 
  summarise(acc_conditional_mean = mean(is_correct, na.rm = T)) %>% 
  ungroup()
```

Transforming grouping variables to factors.

```{r}
main_analysis_acc_aggregate <-
  main_analysis_acc_aggregate %>% 
  mutate(is_congruent = as_factor(is_congruent),
         is_previous_congruent = as_factor(is_previous_congruent),
         participant_id = as_factor(participant_id))
```

Running the ANOVA.

```{r}
anova_acc <-
  ezANOVA(data = main_analysis_acc_aggregate, dv = acc_conditional_mean, wid = participant_id, within = .(is_congruent, is_previous_congruent), type = 3)
```

Transforming the results of the ANOVA to a datatable.

```{r}
anova_acc <-
  as_tibble(anova_acc$ANOVA)
```

Extracting F value and df.

```{r}
anova_acc_f_value <-
  anova_acc %>% 
  filter(Effect %in% c("is_congruent",
                       "is_previous_congruent",
                       "is_congruent:is_previous_congruent")) %>% 
  transmute(term = case_when(Effect == "is_congruent" ~ "main_effect_congruent",
                             Effect == "is_previous_congruent" ~ "main_effect_previous_congruent",
                             Effect == "is_congruent:is_previous_congruent" ~ "interaction_effect"),
            f_value = F,
            df = DFd)
```

Calculating raw effects for each participant.

```{r}
main_analysis_acc_participant_level_raw_effect <-
  main_analysis_acc_aggregate %>% 
  ungroup() %>% 
  mutate(condition = case_when(is_previous_congruent == 0L & is_congruent == 0L ~ "ii",
                               is_previous_congruent == 0L & is_congruent == 1L ~ "ic",
                               is_previous_congruent == 1L & is_congruent == 0L ~ "ci",
                               is_previous_congruent == 1L & is_congruent == 1L ~ "cc",
                               TRUE ~ NA_character_)) %>% 
  select(-is_previous_congruent, -is_congruent) %>% 
  spread(key = condition, value = acc_conditional_mean) %>% 
  mutate(congruency_effect = ((cc + ic) / 2) - ((ci + ii) / 2),
         previous_congruency_effect = ((ci + cc) / 2) - ((ii + ic) / 2),
         interaction_effect = (cc - ci) - (ic - ii),
         current_incongruent = ii - ci)
```

Summarizing mean raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_participant_level_raw_effect %>% 
  summarise(main_effect_congruent = mean(congruency_effect, na.rm = T),
            main_effect_previous_congruent = mean(previous_congruency_effect, na.rm = T),
            interaction_effect = mean(interaction_effect, na.rm = T)) %>%  
  gather(key = "term", value = "raw_effect")
```

Joining F values and dfs and raw effects.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>%
  inner_join(., anova_acc_f_value, by = "term")
```

Calculating SE.

```{r}
main_analysis_acc_raw_effect <-
  main_analysis_acc_raw_effect %>% 
  mutate(se = abs(raw_effect / sqrt(f_value)))
```

#### Running the analysis

Saving the values needed for the analysis.

```{r}
# Obtained sd
acc_se <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(se)

# Obtained effect
acc_effect <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(raw_effect)

# Df
acc_df <- 
  main_analysis_acc_raw_effect %>% 
  filter(term == "interaction_effect") %>% 
  pull(df)
```

Running the Bayes factor analysis.

```{r}
Bf(sd = acc_se,
   obtained = acc_effect,
   dfdata = acc_df,
   meanoftheory = 0,
   sdtheory = .03,
   dftheory = 10^10,
   tail = 1)
```